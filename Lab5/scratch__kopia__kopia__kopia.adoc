:imagesdir: Images
:toc:
:toc-title: Оглавление

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по лабораторной работе №5

[.text-right]
Выполнили: +
студенты группы КЭ-415 +
Кабаков Д.Э. +
Каримов К.А.


== Задание к работе
    а. Сделать тоже самое, что и в прошлом задании, за одним исключением, см пункт 2
    б. Тактирование системной частоты произвести с модуля PLL, так, чтобы системная частота была 30 МГц.

== Написание программы для реализации зажигания светодиодов по нажатию кнопки
Напишем программу, которая зажигает светодиоды по нажатию кнопки.

Также подключим библиотеки "gpioaregisters.hpp" и "gpiocregisters.hpp" для того, чтобы зажигались все светодиоды.

Результат представлен ниже.

[source, c]
#include "rccregisters.hpp" // for RCC
#include "gpiocregisters.hpp" //for GPIOC
#include "gpioaregisters.hpp" //for GPIOA
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C"
{
int __low_level_init(void)
{
//Switch on external 16 MHz oscillator
RCC::CR::HSEON::On::Set();
while (RCC::CR::HSERDY::NotReady::IsSet())
{
}
//Switch system clock on external oscillator
RCC::PLLCFGR::PLLN0::Set(60);
RCC::PLLCFGR::PLLM0::Set(16);
RCC::CR::PLLON::On::Set();
while (RCC::CR::PLLRDY::Unclocked::IsSet())
{
}
RCC::CFGR::SW::Pll::Set();
while (!RCC::CFGR::SWS::Pll::IsSet())
{
}
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  GPIOA::OSPEEDR::OSPEEDR5::MediumSpeed::Set(); // MediumSpeed for Diode 1
  GPIOA::MODER::MODER5::Output::Set();
  GPIOC::OSPEEDR::OSPEEDR5::MediumSpeed::Set(); // MediumSpeed for Diode 2
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::OSPEEDR::OSPEEDR9::MediumSpeed::Set(); // MediumSpeed for Diode 3
  GPIOC::MODER::MODER9::Output::Set();
  GPIOC::OSPEEDR::OSPEEDR8::MediumSpeed::Set(); // MediumSpeed for Diode 4
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::OSPEEDR::OSPEEDR13::MediumSpeed::Set(); // MediumSpeed for User Button
  GPIOC::MODER::MODER13::Input::Set();
return 1;
}
}
int delay(int cycles)
{
    for (int i =0; i< cycles; ++i)
        {
            asm volatile ("");
        }
}
int main()
{
/*GPIOA::ODR::ODR5::High::Set();
GPIOA::ODR::ODR5::Low::Set();
RCC::AHB1ENR::GPIOAEN::Enable::Set();
RCC::AHB1ENR::GPIOCEN::Enable::Set();
GPIOA::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER8::Output::Set();
GPIOC::MODER::MODER9::Output::Set();
GPIOC::MODER::MODER5::Output::Set();*/
{
for (;;)
{
  static uint8_t flag = 0;
  if (GPIOC::IDR::IDR13::Low::IsSet() && flag == 0) // First User Button pushing
  {
    GPIOA::ODR::ODR5::High::Set();
    GPIOC::ODR::ODR5::High::Set();
    GPIOC::ODR::ODR8::High::Set();
    GPIOC::ODR::ODR9::High::Set();
    flag = 1;
    continue;
  }
  if (GPIOC::IDR::IDR13::Low::IsSet() && flag == 1) // Second User Button pushing
  {
    GPIOA::ODR::ODR5::Low::Set();
    GPIOC::ODR::ODR5::Low::Set();
    GPIOC::ODR::ODR8::Low::Set();
    GPIOC::ODR::ODR9::Low::Set();
    flag = 0;
    continue;
  }
  }
return 0;
}

== Подключение платы к компьютеру
Подключим отладчик к плате, и подключим плату к компьютеру. Результат представлен на рисунке 1.

image::image-2021-09-30-23-18-52-173.png[]

Рисунок 1 - Подключенная плата

Светодиод на отладчике горит красным, что говорит нам о том, что плата не прошита.

== Прошивка платы

Успешно прошиваем плату. Можем убедиться в этом, увидев одновременно горящие светодиоды на плате.
Результат представлен на рисунке 2.

image::5.gif[]

Рисунок 2 - Прошитая плата